# Roadmap развития Go-демона: Погружение в IO, Bytes и FS

Этот план содержит три непересекающихся вектора развития проекта. Цель — освоить низкоуровневую работу с данными и файлами, как это делается в высоконагруженных системах (BigTech/FinTech).

---

## 1. Вектор «WAL-Logger» (Write-Ahead Logging & Rotation)
**Суть:** Замена консольного вывода на высокопроизводительное логирование в файлы с управлением ресурсами.

* **Изменение:** Реализация структуры `FileLogger`, которая удовлетворяет интерфейсу `io.Writer`. Вместо прямого `os.Write`, данные сначала попадают в `bytes.Buffer` (или `bufio.Writer`), а при достижении лимита в N байт или по таймеру — сбрасываются на диск. При превышении размера файла (например, 10MB) — старый файл переименовывается (ротация), создается новый.
* **Что дает:** Глубокое понимание интерфейсов `io.Writer`, `io.Closer`, работы с флагами `os.OpenFile` (`O_APPEND`, `O_CREATE`) и системных вызовов для манипуляции файлами (`os.Rename`, `os.Stat`).
* **Что затрагивает:** Создание пакета `internal/logger`, рефакторинг всех джоб для использования логгера вместо `fmt.Printf`.
* **Почему полезно (BigTech):** В облачных сервисах и базах данных (например, PostgreSQL или Kafka) запись всегда идет через WAL и буферы. Прямая запись в диск на каждый лог убивает производительность (IOPS).

---

## 2. Вектор «Binary Persistence» (Стейт-менеджмент)
**Суть:** Реализация сохранения «снэпшота» состояния приложения в кастомном бинарном формате.

* **Изменение:** Перед завершением работы (Graceful Shutdown) демон должен собрать текущие метрики и статусы джоб, упаковать их в бинарный поток через `encoding/binary` и пакет `bytes`, после чего записать в файл `state.bin`. При старте — прочитать файл и инициализировать джобы с теми же весами/счетчиками.
* **Что дает:** Навык работы с пакетом `bytes` (управление слайсами байт без аллокаций), понимание порядка байт (Little/Big Endian) и работы с `io.ReadFull` / `io.SectionReader`.
* **Что затрагивает:** Методы `Do` в джобах (нужно уметь отдавать состояние) и логику инициализации в `main.go`.
* **Почему полезно (FinTech):** Бинарные протоколы (Protobuf, Avro, кастомные форматы) — стандарт в финтехе. Они в десятки раз быстрее и компактнее, чем JSON/XML. Умение работать с "сырыми" байтами — это водораздел между Junior и Middle+ разработчиком.

---

## 3. Вектор «Stream ETL Processor» (Потоковая обработка)
**Суть:** Добавление новой функциональной джобы для обработки тяжелых файлов без нагрузки на RAM.

* **Изменение:** Создать `FileProcessingJob`, которая следит за директорией. При появлении файла она должна:
    1. Прочитать заголовок (первые 512 байт) через `io.ReadAtLeast`, чтобы определить тип файла.
    2. Если файл валиден — прогнать его через цепочку `io.Reader` (например, посчитать контрольную сумму, изменить регистр текста, сжать) и записать результат в выходную папку.
    3. **Важно:** Использовать `io.Copy` или `io.Pipe`, чтобы потребление памяти было стабильно низким (например, 4KB RAM на файл в 4GB).
* **Что дает:** Мастерство работы с потоками (Streams), понимание `io.Pipe`, `io.TeeReader`, `io.MultiWriter` и пакета `os` для работы с директориями.
* **Что затрагивает:** Исключительно создание новой джобы и добавление её в воркер.
* **Почему полезно (BigTech):** Обработка терабайтных логов или медиафайлов — классика. Если твой сервис "падает" по OOM (Out of Memory) при попытке прочитать файл `os.ReadFile`, ты не пройдешь испытательный срок в приличной компании.

---